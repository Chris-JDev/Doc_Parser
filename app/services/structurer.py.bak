"""JSON structuring service using LLM model."""
import json
import logging
import time
import re
from pathlib import Path
from typing import Optional, Tuple, List
from pydantic import ValidationError
from app.config import STRUCTURING_MODEL, JSON_DIR
from app.services.ollama_client import structuring_client
from app.schemas import DocumentSchema, MultiInvoiceOutput, get_json_template, get_multi_invoice_template

logger = logging.getLogger(__name__)


def get_single_page_prompt(extracted_text: str, page_number: int) -> str:
    """Build the prompt for structuring a single page's text into JSON."""
    template = get_json_template()
    
    return f"""Extract invoice/receipt data from this text into JSON.

TEXT:
{extracted_text}

RULES:
- Output ONLY valid JSON, no markdown, no trailing commas
- document_number = any ID (invoice#, receipt#, bill#, order#, PO#, reference#, transaction ID, etc.)
- DO NOT calculate or infer totals/taxes; copy numbers exactly as written in the text
- Keep every numeric value as a number (9.77), not a string; if unsure use null
- Each line item MUST have separate fields: description, quantity, unit_price, line_total (do NOT put everything in description)
- registrations MUST be an array of objects like [{{"type": "VAT", "value": "XX123"}}], NOT an array of strings
- payment_details must be an array of strings; if none present, use []
- Dates as YYYY-MM-DD when present, else null
- Use null for missing values, [] for empty arrays
- page_start={page_number}, page_end={page_number}

TEMPLATE:
{template}

JSON:"""


def get_single_page_repair_prompt(invalid_json: str, error_message: str, page_number: int) -> str:
    """Build a prompt to repair invalid JSON for a single page."""
    template = get_json_template()
    
    return f"""Fix this JSON. Error: {error_message}

BROKEN:
{invalid_json}

TEMPLATE:
{template}

RULES:
- Return ONLY valid JSON, no markdown, no trailing commas
- Do not invent or recalculate numbers; keep numbers exactly as written, or null if unsure
- Keep line items exactly as present; if missing, return an empty array
- payment_details must be an array of strings; if missing, use []
- Dates as YYYY-MM-DD when present, else null
- page_start={page_number}, page_end={page_number}

Corrected JSON:"""


def get_structuring_prompt(extracted_text: str, page_count: int = 1) -> str:
    """Build the prompt for structuring extracted text into JSON."""
    template = get_multi_invoice_template()
    
    return f"""Extract all invoices/receipts from this {page_count}-page document into JSON.

TEXT:
{extracted_text}

RULES:
- Output ONLY valid JSON, no markdown, no trailing commas
- document_number = any ID (invoice#, receipt#, bill#, order#, PO#, reference#, transaction ID, etc.)
- Do NOT calculate totals/taxes; copy numbers exactly as written, or null if unsure
- Each line item MUST have separate fields: description, quantity, unit_price, line_total (do NOT combine into description)
- registrations MUST be an array of objects like [{{"type": "VAT", "value": "XX123"}}], NOT an array of strings
- Numbers must be numeric (9.77), not strings; if a number is missing/unclear use null
- payment_details must be an array of strings; if none, use []
- Dates as YYYY-MM-DD when present, else null
- Use null for missing values, [] for empty arrays
- Set page_start/page_end for each invoice
- Return {{"invoices": [...]}}

TEMPLATE:
{template}

JSON:"""


def get_repair_prompt(invalid_json: str, error_message: str) -> str:
    """Build a prompt to repair invalid JSON."""
    template = get_multi_invoice_template()
    
    return f"""Fix this JSON. Error: {error_message}

BROKEN:
{invalid_json}

TEMPLATE:
{template}

RULES:
- Output ONLY valid JSON, no markdown, no trailing commas
- Do NOT invent or recalculate numbers; copy numbers exactly as written or use null if unsure
- Keep invoices and line items exactly as present; if missing, return empty arrays
- payment_details must be an array of strings; if missing, use []
- Dates as YYYY-MM-DD when present, else null
- Format result as {{"invoices": [...]}}

Corrected JSON:"""


class JSONStructurer:
    """Structure extracted text into JSON using LLM."""
    
    def __init__(self, model: str = STRUCTURING_MODEL):
        """
        Initialize structurer.
        
        Args:
            model: LLM model name for structuring (default from config)
        """
        self.model = model
    
    def _extract_json_from_response(self, response: str) -> str:
        """Extract JSON from model response, handling markdown blocks."""
        response = response.strip()
        
        # Try to extract from markdown code block
        json_match = re.search(r'```(?:json)?\s*([\s\S]*?)\s*```', response)
        if json_match:
            return json_match.group(1).strip()
        
        # Try to find JSON object directly
        # Look for first { to last }
        start_idx = response.find('{')
        end_idx = response.rfind('}')
        
        if start_idx != -1 and end_idx != -1 and end_idx > start_idx:
            return response[start_idx:end_idx + 1]
        
        return response
    
    def _validate_json(self, json_str: str) -> Tuple[Optional[DocumentSchema], Optional[str]]:
        """
        Validate JSON against the single invoice schema.
        
        Returns:
            Tuple of (validated_model, error_message)
        """
        logger.debug(f"Validating JSON (length={len(json_str)}): {json_str[:500]}...")
        
        try:
            data = json.loads(json_str)
            logger.debug(f"Parsed JSON keys: {list(data.keys()) if isinstance(data, dict) else type(data)}")
        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error: {e}")
            logger.error(f"Raw JSON: {json_str[:1000]}")
            return None, f"Invalid JSON syntax: {e}"
        
        try:
            model = DocumentSchema(**data)
            logger.info(f"Validation successful")
            return model, None
        except ValidationError as e:
            errors = e.errors()
            error_msgs = [f"{err['loc']}: {err['msg']}" for err in errors[:5]]
            logger.error(f"Validation errors: {error_msgs}")
            logger.debug(f"Data that failed: {json.dumps(data, indent=2)[:1000]}")
            return None, f"Schema validation failed: {'; '.join(error_msgs)}"
    
    def _validate_multi_json(self, json_str: str) -> Tuple[Optional[MultiInvoiceOutput], Optional[str]]:
        """
        Validate JSON against the multi-invoice schema.
        
        Returns:
            Tuple of (validated_model, error_message)
        """
        try:
            data = json.loads(json_str)
        except json.JSONDecodeError as e:
            return None, f"Invalid JSON syntax: {e}"
        
        # Handle case where model returns single invoice (wrap it)
        if "invoices" not in data and "document" in data:
            data = {"invoices": [data]}
        
        try:
            model = MultiInvoiceOutput(**data)
            return model, None
        except ValidationError as e:
            errors = e.errors()
            error_msgs = [f"{err['loc']}: {err['msg']}" for err in errors[:3]]
            return None, f"Schema validation failed: {'; '.join(error_msgs)}"
    
    async def structure_text(
        self,
        extracted_text: str,
        page_count: int = 1,
        allow_repair: bool = True
    ) -> Tuple[Optional[List[DocumentSchema]], str, int, Optional[str]]:
        """
        Structure extracted text into JSON, supporting multiple invoices.
        
        Args:
            extracted_text: Combined text from all pages
            page_count: Number of pages in document
            allow_repair: Whether to attempt repair on validation failure
        
        Returns:
            Tuple of (list_of_validated_invoices, raw_response, time_ms, error_message)
        """
        logger.info(f"Structuring extracted text into JSON ({page_count} pages)")
        
        start_time = time.time()
        
        try:
            # First attempt
            prompt = get_structuring_prompt(extracted_text, page_count)
            response = await structuring_client.structure_text(prompt)
            
            json_str = self._extract_json_from_response(response)
            model, error = self._validate_multi_json(json_str)
            
            if model is not None:
                elapsed_ms = int((time.time() - start_time) * 1000)
                logger.info(f"Successfully structured {len(model.invoices)} invoice(s) in {elapsed_ms}ms")
                return model.invoices, json_str, elapsed_ms, None
            
            # First attempt failed, try repair if allowed
            if allow_repair:
                logger.warning(f"First attempt failed: {error}. Attempting repair...")
                
                repair_prompt = get_repair_prompt(json_str, error)
                repair_response = await structuring_client.structure_text(repair_prompt)
                
                repair_json_str = self._extract_json_from_response(repair_response)
                model, repair_error = self._validate_multi_json(repair_json_str)
                
                if model is not None:
                    elapsed_ms = int((time.time() - start_time) * 1000)
                    logger.info(f"Repair successful: {len(model.invoices)} invoice(s) in {elapsed_ms}ms")
                    return model.invoices, repair_json_str, elapsed_ms, None
                
                # Both attempts failed
                elapsed_ms = int((time.time() - start_time) * 1000)
                logger.error(f"Repair also failed: {repair_error}")
                return None, repair_json_str, elapsed_ms, f"Validation failed after repair: {repair_error}"
            
            # No repair allowed, return error
            elapsed_ms = int((time.time() - start_time) * 1000)
            return None, json_str, elapsed_ms, error
            
        except Exception as e:
            elapsed_ms = int((time.time() - start_time) * 1000)
            logger.error(f"Error during structuring: {e}")
            return None, "", elapsed_ms, str(e)
    
    async def structure_single_page(
        self,
        extracted_text: str,
        page_number: int,
        allow_repair: bool = True
    ) -> Tuple[Optional[DocumentSchema], str, int, Optional[str]]:
        """
        Structure a single page's text into JSON.
        
        Args:
            extracted_text: Text from a single page
            page_number: Page number (1-based)
            allow_repair: Whether to attempt repair on validation failure
        
        Returns:
            Tuple of (validated_invoice, raw_response, time_ms, error_message)
        """
        logger.info(f"Structuring page {page_number} into JSON")
        
        start_time = time.time()
        
        try:
            # First attempt
            prompt = get_single_page_prompt(extracted_text, page_number)
            response = await structuring_client.structure_text(prompt)
            
            json_str = self._extract_json_from_response(response)
            model, error = self._validate_json(json_str)
            
            if model is not None:
                # Ensure page_start and page_end are set
                model.page_start = page_number
                model.page_end = page_number
                elapsed_ms = int((time.time() - start_time) * 1000)
                logger.info(f"Successfully structured page {page_number} in {elapsed_ms}ms")
                return model, json_str, elapsed_ms, None
            
            # First attempt failed, try repair if allowed
            if allow_repair:
                logger.warning(f"First attempt failed for page {page_number}: {error}. Attempting repair...")
                
                repair_prompt = get_single_page_repair_prompt(json_str, error, page_number)
                repair_response = await structuring_client.structure_text(repair_prompt)
                
                repair_json_str = self._extract_json_from_response(repair_response)
                model, repair_error = self._validate_json(repair_json_str)
                
                if model is not None:
                    model.page_start = page_number
                    model.page_end = page_number
                    elapsed_ms = int((time.time() - start_time) * 1000)
                    logger.info(f"Repair successful for page {page_number} in {elapsed_ms}ms")
                    return model, repair_json_str, elapsed_ms, None
                
                # Both attempts failed
                elapsed_ms = int((time.time() - start_time) * 1000)
                logger.error(f"Repair also failed for page {page_number}: {repair_error}")
                return None, repair_json_str, elapsed_ms, f"Validation failed after repair: {repair_error}"
            
            # No repair allowed, return error
            elapsed_ms = int((time.time() - start_time) * 1000)
            return None, json_str, elapsed_ms, error
            
        except Exception as e:
            elapsed_ms = int((time.time() - start_time) * 1000)
            logger.error(f"Error during structuring page {page_number}: {e}")
            return None, "", elapsed_ms, str(e)
    
    def save_page_json(
        self,
        invoice: DocumentSchema,
        document_id: str,
        page_number: int
    ) -> Path:
        """
        Save a single page's JSON to file.
        
        Args:
            invoice: Validated invoice schema
            document_id: Document identifier
            page_number: Page number (1-based)
        
        Returns:
            Path to saved JSON file
        """
        JSON_DIR.mkdir(parents=True, exist_ok=True)
        json_path = JSON_DIR / f"{document_id}_page_{page_number}.json"
        
        with open(json_path, "w", encoding="utf-8") as f:
            json.dump(invoice.model_dump(), f, indent=2, ensure_ascii=False)
        
        logger.info(f"Saved page {page_number} JSON to {json_path}")
        return json_path

    def save_invoice_json(
        self,
        invoice: DocumentSchema,
        document_id: str,
        invoice_index: int
    ) -> Path:
        """
        Save a single invoice's JSON to file.
        
        Args:
            invoice: Validated invoice schema
            document_id: Document identifier
            invoice_index: Index of this invoice (0-based)
        
        Returns:
            Path to saved JSON file
        """
        JSON_DIR.mkdir(parents=True, exist_ok=True)
        json_path = JSON_DIR / f"{document_id}_invoice_{invoice_index}.json"
        
        with open(json_path, "w", encoding="utf-8") as f:
            json.dump(invoice.model_dump(), f, indent=2, ensure_ascii=False)
        
        logger.info(f"Saved invoice {invoice_index} JSON to {json_path}")
        return json_path
    
    def save_all_invoices_json(
        self,
        invoices: List[DocumentSchema],
        document_id: str
    ) -> Path:
        """
        Save all invoices to a combined JSON file.
        
        Args:
            invoices: List of validated invoice schemas
            document_id: Document identifier
        
        Returns:
            Path to saved JSON file
        """
        JSON_DIR.mkdir(parents=True, exist_ok=True)
        json_path = JSON_DIR / f"{document_id}.json"
        
        data = {"invoices": [inv.model_dump() for inv in invoices]}
        
        with open(json_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Saved {len(invoices)} invoices to {json_path}")
        return json_path
    
    def save_json(
        self,
        model: DocumentSchema,
        document_id: str
    ) -> Path:
        """
        Save structured JSON to file (legacy single-invoice method).
        
        Args:
            model: Validated document schema
            document_id: Document identifier
        
        Returns:
            Path to saved JSON file
        """
        JSON_DIR.mkdir(parents=True, exist_ok=True)
        json_path = JSON_DIR / f"{document_id}.json"
        
        with open(json_path, "w", encoding="utf-8") as f:
            json.dump(model.model_dump(), f, indent=2, ensure_ascii=False)
        
        logger.info(f"Saved structured JSON to {json_path}")
        return json_path
    
    def save_raw_json(
        self,
        raw_json: str,
        document_id: str,
        suffix: str = "_raw"
    ) -> Path:
        """
        Save raw/invalid JSON for debugging.
        
        Args:
            raw_json: Raw JSON string from model
            document_id: Document identifier
            suffix: Filename suffix
        
        Returns:
            Path to saved file
        """
        JSON_DIR.mkdir(parents=True, exist_ok=True)
        json_path = JSON_DIR / f"{document_id}{suffix}.json"
        
        with open(json_path, "w", encoding="utf-8") as f:
            f.write(raw_json)
        
        return json_path


# Global structurer instance
json_structurer = JSONStructurer()
